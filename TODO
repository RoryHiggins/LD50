
Lua Approach
--------------
schema
	Any: function() -> bool
	Null: function(x) -> bool
	Boolean: function(x) -> bool
	String: function(x) -> bool
	Number: function(x) -> bool
	Integer: function(x) -> bool
	Array(t): function(x) -> bool
	Mapping(k, v): function(x) -> bool
	Object(xs, additional_values=false): function(x) -> bool
	AnyOf(...): function(x) -> bool
	AllOf(...): function(x) -> bool
	Enum(...): function(x) -> bool
	Const(c): function(x) -> bool
	Optional(t): function(x) -> bool
	Check(fn): function(x) -> bool
	NormalizedNumber: function(x) -> bool
	NonNegativeNumber: function(x) -> bool
	NonNegativeInteger: function(x) -> bool
	NonEmptyString: function(x) -> bool
	NonEmptyArray(t): function(x) -> bool
	NameString: function(x) -> bool
	Serializable: function(x) -> bool
	SerializableObject: function(x) -> bool
	SerializableArray: function(x) -> bool

sim.Status : schema.Enum{new, running, stopped}
sim.Sys : Metatable
	new_metatable(name: str) : Metatable[sim.Sys]
	on_init()?, on_init()?, on_start()?, on_step()?, on_stop()?
	sys_name: str
sim.Sim
	new(state: schema.SerializableObject|nil, settings: schema.SerializableObject|nil) : Sim
	require(sys_metatable: Metatable[sim.Sys]) : sim.Sys
	find_by_name(sys_name: str) : sim.Sys|nil
	broadcast(event_name: str, ...args: [schema.SerializableObject])
	state: schema.SerializableObject
	settings: schema.SerializableObject
	status: sim.Status
	current_step: num
	_systems: {[str]: sim.Sys}
	_systems_ordered: [sim.Sys]
	_systems_by_event: {[str]: [sim.Sys]}

game.Game = sim.Sim
game.Sys = sim.Sys

world.World = sim.Sim
world.Sys = sim.Sys
world.GameSys : game.Sys
	current_world: World
	new_world(state, settings) : World
	set(state: schema.SerializableObject|nil)  # stops running world, sends on_world_new, starts new world
	on_start()  # invokes world.set_status(Status.running)
	on_step()  # invokes world.step()
	on_stop()  # invokes world.set_status(Status.stopped)

camera.Camera : schema.SerializableObject
	transform: {translate_x, translate_y, scale_x, scale_y, rotate_z : num|nil}
	viewport: {x, y, width, height} : num
camera.Sys : sim.Sys
	set(name: str, camera.Camera)
	find(name: str) : camera.Camera|nil
	all() : {[str]: camera.Camera}
	on_start()
	state
		cameras : {[str]: camera.Camera}

client.wrappers
client.Context
	step()
	window: Window
	texture_atlas: client.wrappers.TextureAtlas
	renderer: client.wrappers.Renderer
	vertex_array: client.wrappers.VertexArray
client.RenderTarget
	step()
client.WorldSys : world.Sys
	on_start()  # creates render_target
	on_step()  # render_target.step()
	render_target: client.RenderTarget
	_context: Context
client.GameSys : game.Sys
	on_step()  # invokes context.step(), {game,world}.on_draw(), 
	on_world_new()  # creates client.WorldSys
	state
		window
			width, height, fps_limit: num
			vsync: bool
	context: client.Context

# ^ DONE
# v TODO

controller.Input : schema.SerializableObject
	down: bool
	step_id: num
controller.Controller : schema.SerializableObject
	inputs: {[str]: controller.Input}  # by input name
controller.BindingType : enum str {"keyboard"}
controller.Binding : schema.SerializableObject
	controller_id: num
	input_name: str
	binding_type: controller.BindingType
	binding_keyboard_key: str?
controller.WorldSys : world.Sys
	find(controller_id: num) : controller.Controller|nil
	get_default() : controller.Controller
	get_down(controller_id: num, input_name: str) : bool
	get_toggled(controller_id: num, input_name: str) : bool
	on_input_set(controller_id: num, input_name: str, down: bool)
	state
		controllers: [input.Controller]
controller.GameSys : game.Sys
	on_start(), on_step()  # updates inputs, triggers world.on_input_set()
	get_bindings() : [controller.Binding]
	set_bindings([controller.Binding])
	state
		bindings: [controller.Binding]

entity.Entity : schema.SerializableObject
	name: str|nil
entity.WorldSys : world.Sys
	add(src: schema.SerializableObject|nil) : entity.Entity
	set(entity.Entity, src: schema.SerializableObject|nil)
	update(entity.Entity, src: schema.SerializableObject)
	destroy(entity.Entity)
	all() : [entity.Entity]
	find(name: str) : entity.Entity|nil
	set_name(entity.Entity, name: str) : str
	require_name(entity.Entity) : str
	on_start()
	state
		entities: [entity.Entity]
	_tag_id_to_tag: [str]
	_tag_to_tag_id: {[str]: num}
	_entity_to_entity_id: {[entity.Entity]: num}
	_entity_name_to_entity: {[str]: entity.Entity}
	_tag_to_entities: {[str]: [entity.Entity]}
	_entity_id_lookup_for_tag_to_entities: [{[str]: num}]  # for efficient cleanup of _tag_to_entities
	_entity_index: EntityIndex
	_sprite_game: sprite.GameSys : game.Sys  # for index access to atlas tex coords, which are not in world state

tag.Component : schema.Mapping(schema.String, schema.String)
tag.WorldSys : world.Sys
	is_set(entity.Entity, ...tags: [str]) : bool
	set(entity.Entity, ...tags: [str])  # invokes on_entity_tag_set
	add(entity.Entity, ...tags: [str])
	remove(entity.Entity, ...tags: [str])
	all(tag: str) : [entity.Entity]
	_entity_world: entity.WorldSys

bounds.Component : schema.SerializableObject
	x, y, width, height: num
bounds.WorldSys
	find_in(x, y, width, height: num, entity.Entity, ...tags: [str]) : entity.Entity|nil
	find_all_in(x, y, width, height: num, entity.Entity, ...tags: [str]) : [entity.Entity]
	get(entity.Entity) : num, num, num, num
	set(entity.Entity, x, y: num, width, height: num|nil)
	move(entity.Entity, offset_x, offset_y: num)
	_entity_world: entity.WorldSys

sprite.Sprite : schema.SerializableObject
	file_name: str
	file_type = "png"
	u1, v1, u2, v2: num
sprite.Component : schema.SerializableObject
	sprite_name: str
	z, r, g, b, a, scale_x, scale_y, translate_x, translate_y, rotate: num?
sprite.AtlasRegion
	atlas_region_id: num
	u1, v1, u2, v2: num
sprite.WorldSys : world.Sys
	add_sprite(sprite.Sprite)
	find_sprite(sprite_name: str) : sprite.Sprite
	draw_sprite(client.wrappers.VertexArray, sprite.Component)
	set(entity.Entity, sprite.Component)
	set_name(entity.Entity, sprite_name: str)
	remove(entity.Entity)
	on_draw()  # draw the sprites of entites
	state
		spritesheets: {[str]: sprite.Spritesheet}
sprite.GameSys : game.Sys
	load_png(file_name: str)
	unload(file_name: str)
	_sprite_cache: {[str]: sprite.Allocation}
	_atlas_region_by_filename: {[str]: sprite.AtlasRegion}

animation.Animation : schema.SerializableObject
	frames: [str]  # sprite names
animation.Component : schema.SerializableObject
	anim_name: str
	frame_id: num
	loop: bool
animation.WorldSys : world.Sys
	add_animation(anim_name: str, animation.Animation)
	find_animation(anim_name: str) : animation.Animation|nil
	set(entity.Entity, animation.Component)
	set_name(entity.Entity, anim_name: str)
	set_frame_id(entity.Entity, frame_id: num)
	get_ended(entity.Entity) : bool  # frame_id == #frames
	remove(entity.Entity)
	on_step()  # progress the animation of entities
	_animation_game: animation.GameSys : game.Sys
	_sprite_game: sprite.GameSys : game.Sys

text.Font : schema.SerializableObject
	filename: str
	type = "ascii"  # only currently supported type
text.Component : schema.SerializableObject
	font_name: str
	z, r, g, b, a, translate_x, translate_y, max_width, max_height: num?
text.WorldSys : world.Sys
	add_font(font_name: str, text.Font)
	find_font(font_name: str) : text.Font|nil
	draw_text(client.wrappers.VertexArray, text.Component)
	set(entity.Entity, text.Component)
	set_text(entity.Entity, text: str)
	remove(entity.Entity)
	on_draw()  # draw entity text components
	state
		fonts: 
	_game_text: text.GameSys
text.GameSys : game.Sys
	load(text.Font)
	unload(text.Font)
	_ascii_font_by_filename: {[str]: client.wrappers.AsciiFont}
	_texture_atlas: client.wrappers.TextureAtlas

audio.Audio : schema.SerializableObject
	filename: str
	volume: num  # 0..1
audio.PlaybackId : schema.Number
audio.Playback : schema.SerializableObject
	audio_name: str
	loop_count, cutoff_time, fadein_time, volume : num
	loop_forever : bool
audio.WorldSys : world.Sys
	add(audio_name: str, audio.Audio)
	find(audio_name: str) : audio.Audio|nil
	play(audio.Playback) : audio.PlaybackId
	stop(audio.PlaybackId)
	stop_all()
	_game_audio: audio.GameSys
audio.GameSys : game.Sys
	load(audio.Audio)
	unload(audio.Audio)
	_audio_by_filename: {[str]: client.wrappers.Audio}

music.WorldSys
	play(audio_name: str)
	stop()
	get_name() : str|nil
	state
		audio_name: str

camera_target.Component : schema.SerializableObject
	camera_name: str
	speed: num?
	margin: num?
camera_target.WorldSys : world.Sys
	set(entity.Entity, camera_target.Component)
	remove(entity.Entity)
	on_step()
	on_entity_destroy()  # remove if named view removed

Client TODOs
============
Small important TODOs
	Allocate 1x1 white pixel at topleft of texture atlas

Big TODOs
	Unicode font loading, unicode text rendering
	adjustable 2D positions for positional audio playback?
	streaming audio playback from formats other than wav...?

Refactoring TODOs
	lua bindings: add get_raw_texture() and get_raw_render_texture() to bindings, remove type branching logic in texture init
	rename "target" to "dest" in bindings


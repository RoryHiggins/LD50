
Lua Approach
--------------
schema
	Any: function() -> bool
	Null: function(x) -> bool
	Boolean: function(x) -> bool
	String: function(x) -> bool
	Number: function(x) -> bool
	Integer: function(x) -> bool
	Array(t): function(x) -> bool
	Mapping(k, v): function(x) -> bool
	Object(xs, additional_values=false): function(x) -> bool
	AnyOf(...): function(x) -> bool
	AllOf(...): function(x) -> bool
	Enum(...): function(x) -> bool
	Const(c): function(x) -> bool
	Optional(t): function(x) -> bool
	Check(fn): function(x) -> bool
	NormalizedNumber: function(x) -> bool
	NonNegativeNumber: function(x) -> bool
	NonNegativeInteger: function(x) -> bool
	NonEmptyString: function(x) -> bool
	NonEmptyArray(t): function(x) -> bool
	NameString: function(x) -> bool
	Serializable: function(x) -> bool
	SerializableObject: function(x) -> bool
	SerializableArray: function(x) -> bool

sim.model.Status : schema.Enum{new, running, stopped}
sim.Sim
	new(state: schema.SerializableObject|nil, settings: schema.SerializableObject|nil) : Sim
	require(sys_metatable: Metatable[sim.Sys]) : sim.Sys
	find_by_name(sys_name: str) : sim.Sys|nil
	broadcast(event_name: str, ...args: [schema.SerializableObject])
	get_sys_state(sys: sim.Sys) : schema.SerializableObject
	get_sys_settings(sys: sim.Sys) : schema.SerializableObject
	state: schema.SerializableObject
	settings: schema.SerializableObject
	status: sim.model.Status
	current_step: num
	_systems: {[str]: sim.Sys}
	_systems_ordered: [sim.Sys]
	_systems_by_event: {[str]: [sim.Sys]}
sim.Sys : Metatable
	new_metatable(name: str) : Metatable[sim.Sys]
	on_require(sys)?, on_start()?, on_step()?, on_stop()?
	sys_name: str

game.Game = sim.Sim
game.Sys = sim.Sys

world.World = sim.Sim
world.Sys = sim.Sys
world.game.Sys : game.Sys
	get() : World
	set(World)  # stops running world, sends on_world_set, starts new world
	on_start()  # invokes world.set_status(Status.running)
	on_step()  # invokes world.step()
	on_stop()  # invokes world.set_status(Status.stopped)
	_world: World



client.Context
	window: Window
	texture_atlas: odClient.TextureAtlas
	renderer: odClient.Renderer	
client.game.Sys : game.Sys
	on_start()  # creates and configures resources
	on_step()  # invokes on_draw(odClient.VertexArray, client.Context), window.step()
	settings
		window
			width, height, fps_limit: num
			vsync: bool
	context: client.Context
	_vertices: odClient.VertexArray

view.model.View : schema.SerializableObject
	transform: {translate_x, translate_y, scale_x, scale_y, rotate_z : num|nil}
	viewport: {x, y, w, h} : num
view.game.Sys : world.Sys
	set(name: str, view.model.View)
	find(name: str) : view.model.View|nil
	on_world_set()
	on_draw()  # invokes world.on_draw(odClient.VertexArray, client.Context), adds vertices for each view
	state
		views : {[str]: view.model.View}
view.world.Sys : world.Sys
	set(name: str, view.model.View)
	find(name: str) : view.model.View|nil
	on_start()  # ensures "default" view exists
	on_step()  # invokes world.on_draw(odClient.VertexArray)
	state
		cameras : {[str]: view.model.View}
		_render_target: odClient.RenderTexture
	_vertices: odClient.VertexArray
	_render_target: odClient.RenderTexture

controller.model.Input : schema.SerializableObject
	held: bool
	steps_in_state: num  # for tap detection
	steps_in_last_state: num  # for double-tap detection
controller.model.ControllerInputs : schema.SerializableObject
	inputs: {[str]: controller.model.Input}  # by input name
	get_held(name: str) : bool
	tapped(name: str) : bool
	double_tapped(name: str, max_released_steps: num = 5) : bool
	binding_find(name: str) : controller.model.Binding
	binding_set(name: str, controller.model.Binding)
controller.model.Inputs : schema.SerializableObject
	controllers: [controller.model.ControllerInputs]  # by controller id -> input name
controller.model.BindingType : enum str {"keyboard"}
controller.model.Binding : schema.SerializableObject
	input_name: str
	controller_id: num
	type: controller.model.BindingType
	keyboard_key: str?
controller.game.Sys : game.Sys
	find_controller(controller_id: num, input_name: str) : controller.model.Input|nil
	on_step()  # updates inputs from bindings, triggers world.on_input(name, controller_id, held)
	state
		inputs: controller.model.Inputs
	settings
		bindings: [controller.model.Binding]
controller.world.Sys : world.Sys
	on_input_change()
	state
		inputs: input.model.Inputs

entity.model.Entity : schema.SerializableObject
	name: str|nil
entity.world.Sys : world.Sys
	add(src: schema.SerializableObject|nil) : entity.model.Entity
	set(entity.model.Entity, src: schema.SerializableObject|nil)
	update(entity.model.Entity, src: schema.SerializableObject)
	destroy(entity.model.Entity)
	iterate() : [entity.model.Entity]
	find(name: str) : entity.model.Entity|nil
	set_name(entity.model.Entity, name: str) : str
	require_name(entity.model.Entity) : str
	on_start()
	state
		entities: [entity.model.Entity]
	_tag_id_to_tag: [str]
	_tag_to_tag_id: {[str]: num}
	_entity_to_entity_id: {[entity.model.Entity]: num}
	_entity_name_to_entity: {[str]: entity.model.Entity}
	_tag_to_entities: {[str]: [entity.model.Entity]}
	_entity_id_lookup_for_tag_to_entities: [{[str]: num}]  # for efficient cleanup of _tag_to_entities
	_entity_index: EntityIndex
	_sprite_game: sprite.game.Sys : game.Sys  # for index access to atlas tex coords, which are not in world state

tag.model.Component : schema.Mapping(schema.String, schema.String)
tag.world.Sys : world.Sys
	is_set(entity.model.Entity, ...tags: [str]) : bool
	set(entity.model.Entity, ...tags: [str])  # invokes on_entity_tag_set
	add(entity.model.Entity, ...tags: [str])
	remove(entity.model.Entity, ...tags: [str])
	iterate(tag: str) : [entity.model.Entity]
	_entity_world: entity.world.Sys

bounds.model.Component : schema.SerializableObject
	x, y, w, h: num
bounds.world.Sys
	find_in(x, y, w, h: num, entity.model.Entity, ...tags: [str]) : entity.model.Entity|nil
	find_all_in(x, y, w, h: num, entity.model.Entity, ...tags: [str]) : [entity.model.Entity]
	get(entity.model.Entity) : num, num, num, num
	set(entity.model.Entity, x, y: num, w, h: num|nil)
	move(entity.model.Entity, offset_x, offset_y: num)
	_entity_world: entity.world.Sys

sprite.model.Component : schema.SerializableObject
	new(sprite_name: str) : sprite.model.Component
	sprite_name: str
	depth, r, g, b, a, scale_x, scale_y, translate_x, translate_y, rotate: num
sprite.model.Asset : schema.SerializableObject
	file_name: str
	u1, v1, u2, v2: num
sprite.model.Allocation : schema.SerializableObject
	region_id: num
	u1, v1, u2, v2: num
sprite.game.Sys : game.Sys
	add_png(file_name: str, sprites: {[str]: sprite.model.Asset]})
	find(sprite_name: str) : sprite.model.Asset|nil
	draw(odClient.VertexArray, sprite.model.Component, x, y: num)
	get_atlas_coords(sprite_name: str) : num, num, num, num
	on_start()
	state
		sprites: {[str]: sprite.model.Asset}
	_sprite_allocations: {[str]: sprite.model.Allocation}
sprite.world.Sys : world.Sys
	set(entity.model.Entity, sprite.model.Component)
	set_name(entity.model.Entity, sprite_name: str)
	remove(entity.model.Entity)
	draw(odClient.VertexArray, sprite.model.Component, x, y: num)
	on_draw(odClient.VertexArray)  # draw the sprites of entites

animation.model.Component : schema.SerializableObject
	anim_name: str
	pos: num
	loop: bool
	ended: bool
animation.model.Asset : schema.SerializableObject
	frames: [str]
animation.game.Sys : game.Sys
	set(anim_name: str, animation.model.Asset)
	find(anim_name: str) : animation.model.Asset
	on_start()
	state
		animations: {[str]: animation.model.Asset}
	# optimization: index frames by anim for fast frame updates
animation.world.Sys : world.Sys
	set(entity.model.Entity, animation.model.Component)
	set_name(entity.model.Entity, anim_name: str)
	remove(entity.model.Entity)
	on_step()  # progress the animation of entities
	_animation_game: animation.game.Sys : game.Sys
	_sprite_game: sprite.game.Sys : game.Sys

text.model.Component : schema.SerializableObject
	font_name: str
	depth, r, g, b, a, max_width, max_height: num
text.model.FontAsset : schema.SerializableObject
	filename: str
	type = "ascii"  # only currently supported type
text.game.Sys : game.Sys
	set(font_name: str, text.model.FontAsset)
	find(font_name: str) : text.model.FontAsset|nil
	draw(odClient.VertexArray, text.model.Component, x, y: num)
	on_start()
	state
		fonts: {[str]: text.model.FontAsset}
	_ascii_fonts: {[str]: odClient.AsciiFont}
text.world.Sys : world.Sys
	set(entity.model.Entity, text.model.Component)
	set_text(entity.model.Entity, font_name: str, text: str, max_width, max_height: num|nil)
	remove(entity.model.Entity)
	draw(odClient.VertexArray, text.model.Component, x, y: num)
	on_draw(odClient.VertexArray)  # draw the text of entites
	_animation_game: animation.game.Sys : game.Sys
	_sprite_game: sprite.game.Sys : game.Sys

audio.model.PlaybackId : schema.Number
audio.model.PlaybackSettings : schema.SerializableObject
	loop_count, cutoff_time, fadein_time, volume : num
	loop_forever : bool
audio.Asset : schema.SerializableObject
	filename: str
	volume: num  # 0..1
audio.game.Sys : game.Sys
	add(audio_name: str, audio.Asset)
	find(audio_name: str) : audio.Asset|nil
	play(audio.Asset, audio.model.PlaybackSettings|nil) : audio.model.PlaybackId
	playing(audio.model.PlaybackId) : bool
	stop(audio.model.PlaybackId)
	stop_all()

camera_target.model.Component : schema.SerializableObject
	entity_name: str
	speed: num?
	margin: num?
camera_target.world.Sys : world.Sys
	set(entity.model.Entity, camera_target.model.Component)
	remove(entity.model.Entity)
	on_step()
	on_entity_destroy()  # remove if named view removed

Client TODOs
============
Refactoring TODOs
	lua bindings: add get_raw_texture() and get_raw_render_texture() to bindings, remove type branching logic in texture init

Long-term TODOs
	Unicode font loading, unicode text rendering
	adjustable 2D positions for positional audio playback?
	streaming audio playback from formats other than wav...?

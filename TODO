
Lua Approach
--------------
schema
	Any: function() -> bool
	Null: function(x) -> bool
	Boolean: function(x) -> bool
	String: function(x) -> bool
	Number: function(x) -> bool
	Integer: function(x) -> bool
	Array(t): function(x) -> bool
	Mapping(k, v): function(x) -> bool
	Object(xs, additional_values=false): function(x) -> bool
	AnyOf(...): function(x) -> bool
	AllOf(...): function(x) -> bool
	Enum(...): function(x) -> bool
	Const(c): function(x) -> bool
	Optional(t): function(x) -> bool
	Check(fn): function(x) -> bool
	NormalizedNumber: function(x) -> bool
	NonNegativeNumber: function(x) -> bool
	NonNegativeInteger: function(x) -> bool
	NonEmptyString: function(x) -> bool
	NonEmptyArray(t): function(x) -> bool
	NameString: function(x) -> bool
	Serializable: function(x) -> bool
	SerializableObject: function(x) -> bool
	SerializableArray: function(x) -> bool

sim.model.Status : schema.Enum{new, running, stopped}
sim.Sys : Metatable
	new_metatable(name: str) : Metatable[sim.Sys]
	on_init()?, on_init()?, on_start()?, on_step()?, on_stop()?
	sys_name: str
sim.Sim
	new(state: schema.SerializableObject|nil, settings: schema.SerializableObject|nil) : Sim
	require(sys_metatable: Metatable[sim.Sys]) : sim.Sys
	find_by_name(sys_name: str) : sim.Sys|nil
	broadcast(event_name: str, ...args: [schema.SerializableObject])
	state: schema.SerializableObject
	settings: schema.SerializableObject
	status: sim.model.Status
	current_step: num
	_systems: {[str]: sim.Sys}
	_systems_ordered: [sim.Sys]
	_systems_by_event: {[str]: [sim.Sys]}

game.Game = sim.Sim
game.Sys = sim.Sys

world.World = sim.Sim
world.Sys = sim.Sys
world.GameSys : game.Sys
	current_world: World
	new_world(state, settings) : World
	set(state: schema.SerializableObject|nil)  # stops running world, sends on_world_new, starts new world
	on_start()  # invokes world.set_status(Status.running)
	on_step()  # invokes world.step()
	on_stop()  # invokes world.set_status(Status.stopped)

camera.model.Camera : schema.SerializableObject
	transform: {translate_x, translate_y, scale_x, scale_y, rotate_z : num|nil}
	viewport: {x, y, width, height} : num
camera.Sys : sim.Sys
	set(name: str, camera.model.Camera)
	find(name: str) : camera.model.Camera|nil
	all() : {[str]: camera.model.Camera}
	on_start()
	state
		cameras : {[str]: camera.model.Camera}

client.wrappers
client.Context
	step()
	window: Window
	texture_atlas: client.wrappers.TextureAtlas
	renderer: client.wrappers.Renderer
	vertex_array: client.wrappers.VertexArray
client.RenderTarget
	step()
client.WorldSys : world.Sys
	on_start()  # creates render_target
	on_step()  # render_target.step()
	render_target: client.RenderTarget
	_context: Context
client.GameSys : game.Sys
	on_step()  # invokes context.step(), {game,world}.on_draw(), 
	on_world_new()  # creates client.WorldSys
	settings
		window
			width, height, fps_limit: num
			vsync: bool
	context: client.Context

# ^ DONE
# v TODO

controller.model.Input : schema.SerializableObject
	held: bool
	steps_in_state: num  # for tap detection
	steps_in_last_state: num  # for double-tap detection
controller.model.ControllerInputs : schema.SerializableObject
	inputs: {[str]: controller.model.Input}  # by input name
	get_held(name: str) : bool
	tapped(name: str) : bool
	double_tapped(name: str, max_released_steps: num = 5) : bool
	binding_find(name: str) : controller.model.Binding
	binding_set(name: str, controller.model.Binding)
controller.model.Inputs : schema.SerializableObject
	controllers: [controller.model.ControllerInputs]  # by controller id -> input name
controller.model.BindingType : enum str {"keyboard"}
controller.model.Binding : schema.SerializableObject
	input_name: str
	controller_id: num
	type: controller.model.BindingType
	keyboard_key: str?
controller.WorldSys : world.Sys
	on_input_change()
	state
		inputs: input.model.Inputs
controller.GameSys : game.Sys
	find_controller(controller_id: num, input_name: str) : controller.model.Input|nil
	on_step()  # updates inputs from bindings, triggers world.on_input(name, controller_id, held)
	state
		inputs: controller.model.Inputs
	settings
		bindings: [controller.model.Binding]

entity.model.Entity : schema.SerializableObject
	name: str|nil
entity.WorldSys : world.Sys
	add(src: schema.SerializableObject|nil) : entity.model.Entity
	set(entity.model.Entity, src: schema.SerializableObject|nil)
	update(entity.model.Entity, src: schema.SerializableObject)
	destroy(entity.model.Entity)
	all() : [entity.model.Entity]
	find(name: str) : entity.model.Entity|nil
	set_name(entity.model.Entity, name: str) : str
	require_name(entity.model.Entity) : str
	on_start()
	state
		entities: [entity.model.Entity]
	_tag_id_to_tag: [str]
	_tag_to_tag_id: {[str]: num}
	_entity_to_entity_id: {[entity.model.Entity]: num}
	_entity_name_to_entity: {[str]: entity.model.Entity}
	_tag_to_entities: {[str]: [entity.model.Entity]}
	_entity_id_lookup_for_tag_to_entities: [{[str]: num}]  # for efficient cleanup of _tag_to_entities
	_entity_index: EntityIndex
	_sprite_game: sprite.GameSys : game.Sys  # for index access to atlas tex coords, which are not in world state

tag.model.Component : schema.Mapping(schema.String, schema.String)
tag.WorldSys : world.Sys
	is_set(entity.model.Entity, ...tags: [str]) : bool
	set(entity.model.Entity, ...tags: [str])  # invokes on_entity_tag_set
	add(entity.model.Entity, ...tags: [str])
	remove(entity.model.Entity, ...tags: [str])
	all(tag: str) : [entity.model.Entity]
	_entity_world: entity.WorldSys

bounds.model.Component : schema.SerializableObject
	x, y, width, height: num
bounds.WorldSys
	find_in(x, y, width, height: num, entity.model.Entity, ...tags: [str]) : entity.model.Entity|nil
	find_all_in(x, y, width, height: num, entity.model.Entity, ...tags: [str]) : [entity.model.Entity]
	get(entity.model.Entity) : num, num, num, num
	set(entity.model.Entity, x, y: num, width, height: num|nil)
	move(entity.model.Entity, offset_x, offset_y: num)
	_entity_world: entity.WorldSys

sprite.model.Sprite : schema.SerializableObject
	file_name: str
	u1, v1, u2, v2: num
sprite.model.Component : schema.SerializableObject
	new(sprite_name: str) : sprite.model.Component
	sprite_name: str
	z, r, g, b, a, scale_x, scale_y, translate_x, translate_y, rotate: num
sprite.model.Allocation
	atlas_region_id: num
	u1, v1, u2, v2: num
sprite.WorldSys : world.Sys
	set(entity.model.Entity, sprite.model.Component)
	set_name(entity.model.Entity, sprite_name: str)
	remove(entity.model.Entity)
	draw(client.wrappers.VertexArray, sprite.model.Component, x, y: num)
	on_draw()  # draw the sprites of entites
sprite.GameSys : game.Sys
	add_png(file_name: str, sprites: {[str]: sprite.model.Sprite]})
	find(sprite_name: str) : sprite.model.Sprite|nil
	draw(client.wrappers.VertexArray, sprite.model.Component, x, y: num)
	get_atlas_coords(sprite_name: str) : num, num, num, num
	on_start()
	state
		sprites: {[str]: sprite.model.Sprite}
	_sprite_allocations: {[str]: sprite.model.Allocation}

animation.model.Animation : schema.SerializableObject
	frames: [str]
animation.model.Component : schema.SerializableObject
	anim_name: str
	pos: num
	loop: bool
	ended: bool
animation.WorldSys : world.Sys
	set(entity.model.Entity, animation.model.Component)
	set_name(entity.model.Entity, anim_name: str)
	remove(entity.model.Entity)
	on_step()  # progress the animation of entities
	_animation_game: animation.GameSys : game.Sys
	_sprite_game: sprite.GameSys : game.Sys

animation.GameSys : game.Sys
	set(anim_name: str, animation.model.Animation)
	find(anim_name: str) : animation.model.Animation
	on_start()
	state
		animations: {[str]: animation.model.Animation}
	# optimization: index frames by anim for fast frame updates

text.model.Font : schema.SerializableObject
	filename: str
	type = "ascii"  # only currently supported type
text.model.Component : schema.SerializableObject
	font_name: str
	z, r, g, b, a, max_width, max_height: num
text.WorldSys : world.Sys
	set(entity.model.Entity, text.model.Component)
	set_text(entity.model.Entity, font_name: str, text: str, max_width, max_height: num|nil)
	remove(entity.model.Entity)
	draw(client.wrappers.VertexArray, text.model.Component, x, y: num)
	on_draw()  # draw the text of entites
	_animation_game: animation.GameSys : game.Sys
	_sprite_game: sprite.GameSys : game.Sys
text.GameSys : game.Sys
	set(font_name: str, text.model.Font)
	find(font_name: str) : text.model.Font|nil
	draw(client.wrappers.VertexArray, text.model.Component, x, y: num)
	on_start()
	state
		fonts: {[str]: text.model.Font}
	_ascii_font_assets: {[str]: client.wrappers.AsciiFont}

audio.model.Audio : schema.SerializableObject
	filename: str
	volume: num  # 0..1
audio.model.PlaybackSettings : schema.SerializableObject
audio.model.PlaybackId : schema.Number
	loop_count, cutoff_time, fadein_time, volume : num
	loop_forever : bool
audio.GameSys : game.Sys
	add(audio_name: str, audio.model.Audio)
	find(audio_name: str) : audio.model.Audio|nil
	play(audio.model.Audio, audio.model.PlaybackSettings|nil) : audio.model.PlaybackId
	playing(audio.model.PlaybackId) : bool
	stop(audio.model.PlaybackId)
	stop_all()
	state
		audio: [audio.model.Audio]
	_assets: {[str]: client.wrappers.Audio}

camera_target.model.Component : schema.SerializableObject
	entity_name: str
	speed: num?
	margin: num?
camera_target.WorldSys : world.Sys
	set(entity.model.Entity, camera_target.model.Component)
	remove(entity.model.Entity)
	on_step()
	on_entity_destroy()  # remove if named view removed

Client TODOs
============
Big TODOs
	Unicode font loading, unicode text rendering
	adjustable 2D positions for positional audio playback?
	streaming audio playback from formats other than wav...?

Refactoring TODOs
	lua bindings: add get_raw_texture() and get_raw_render_texture() to bindings, remove type branching logic in texture init
	rename "target" to "dest" in bindings

